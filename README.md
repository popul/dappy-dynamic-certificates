# Use Dappy as remote trusted certificate store

Today, managing certificates is a pain for many companies. When exposing a B2B portal, online SaaS or APi, they are exposed to many security and downtime risks coming from corrupted certificates or simply downtimes. When a company discovers that a security breach has been exploited through Man-In-The-Middle TLS interception, it is often too late. Expired certificates also expose the clients and partners to downtimes and reduce their trust.

**Post incident analysis raises the following questions : Why are we are in this situation and can we do anything to remediate it ?**

## What are certificates and stores ?

Certificates are the angular stone of TLS protocol and allow two computers to communicate in a secure way, giving garantees like data integrity, confidentiality and authentication. There are two types of certificates. First one is called **server certificate**. It is delivered by company and institution servers and it contains the server identity. Server certificates are signed by the second type of certificate, **trusted certificates** (intermediate and root certificates). They are installed on client devices, like computers and mobile phones. A server certificate is considered trusted if it is signed by a trusted certificate, that is already known by end user, this is the concept of [chain of trust](https://en.wikipedia.org/wiki/Chain_of_trust).

For public web, trusted certificates are distributed over Web PKI root stores, authored by browser companies like [Mozilla](https://wiki.mozilla.org/CA), [Microsoft](https://docs.microsoft.com/en-us/security/trusted-root/program-requirements), [Google](https://www.chromium.org/Home/chromium-security/root-ca-policy/), [Apple](https://www.apple.com/certificateauthority/ca_program.html). They contains hundreds of certificates owned by public [certificate authorities](https://en.wikipedia.org/wiki/Certificate_authority). To be trusted by end users, these trusted certificates have to be installed on their local stores. Usually, this is done during software updates.

## What's wrong with certificates stores ?

First of all, end users trust servers because they trust related certificates installed locally and not only because these servers have been signed by a actual certificate authority. Local trusted certificates may differ from trusted certificates listed by Web PKI root stores. Quite evidently, the larger this gap, the higher the security risk. Navigating on the public web with an outdated local certificate store can be extremely insecure.

Also, certificates can’t be easily repudiated. If it has been signed by an another trusted certificate (by its corresponding private key), the cryptographic proof (signature) is valid forever. CRL and OCSP protocols allow to do repudiation, but the burden to check the validity of certificates is on the softwares that interpret these OCSP and CRL metadata. OCSP and CRL are overlays, they may be interpreted differently by softwares, they do not and cannot invalidate CA signatures. OCSP and CRL protocols do not guarantee that your clients and partners are browsing your website with non revoked certificates. Of course, setting an expiration date minimizes the attack surface, but that's only half of a solution. Moreover, how would you install the new certificate before the expiry date in the local root store ? 

In order to be valid, a certificate must be signed by a certificate authority that your computer trusts. It means that **your server identity can be impersonated or revoked by any certificate authority.** For example, on apple devices, [164 root certificates](https://support.apple.com/en-us/HT212140) are valid. Who can guarantee today that all certificate authorities are not influenced by countries like United States or China ? War in Ukraine recently showed us an example of the [possibility](https://www.bleepingcomputer.com/news/security/russia-creates-its-own-tls-certificate-authority-to-bypass-sanctions/) that no one is the owner of its server identity. It just takes one trusted certificate authority to be compromised for your (or your client's) TLS communications to be exposed to man in the middle attacks. Of course, it is mitigated by [CT Logs](https://datatracker.ietf.org/doc/html/rfc6962), but it's still possible. This attack is called TLS interception and is used in company intranets to prevent data leaks. But few people realize that we are also exposed to this attack on the public web. 

Public names are managed by [DNS](https://en.wikipedia.org/wiki/Domain_Name_System), which is the public name authority. So, we have a registry for public names, but it’s not the case for certificates. To be exact, we have as many certificate registries as root certificate authorities which are private by default. This lack of visibility about certificates is the first problem that a PKI must resolve, and it’s not an easy one. Intuitively, if you are the owner of a domain name, only you can endorse this name, but as argued earlier it’s more complicated with the PKI and root stores of the public web. What happens when domain name has a new owner ? You guessed … certificates are still valid. And conversely, why a certificate becomes invalid despite the fact that name ownership hasn’t changed.

Many attempts were made to patch DNS and allow DNS zones to store TLS certificates, [RFC 4398](https://www.rfc-editor.org/rfc/rfc4398), or to save certificate fingerprints with [DANE](https://datatracker.ietf.org/doc/html/rfc6698). But DNS failed to be secured using DNSSEC (https://datatracker.ietf.org/doc/html/rfc4033) in an end to end way.

As we discussed, many problems are related to local root certificate stores. At Fabco, we are convinced that too much trust is delegated to local stores and their trusted certificates. Revocated certificates are still used by end users and no system give this garantee today. Also, in practice, anyone that wants to secure their public communications, **has** to provide a certificate signed by one these trusted certificates. They are owned by certificate authorities, whom are all exposed to security issues. If just one authority is compromised, all public secured communications are compromised because a root authority can create a certificate for any domain **without the owner's permission**. Today, we implicitly accept this **single point of failure** because it's the only effectuve way to secure communications and transactions on Internet.

## Solutions

People and companies just want to communicate in a private manner on Internet. For communications without significant value, the web public key infrastructure is an acceptable tradeoff. But is it an acceptable solution within a world more and more digitalized where the amount of value transactions has totally skyrocketed in recent years ? Today, [home ownership can be digitalized using NFTs](https://www.forbes.com/sites/forbesbusinesscouncil/2022/02/16/nfts-and-the-future-of-commercial-real-estate/) and exchanged publicly and the number of cyber attacks has never been so high.

In theory, to secure a TLS communication, you have to emit a server certificate, distribute it with your web server and finally clients just have to trust it, but how ? On public web, server certificates are signed by trusted certificates that are preinstalled on clients. As argued earlier, these trusted certificates can be outdated or worse, compromised and revoked. How to garantee to our client to use latest trusted certificates ? Issuing signed certificates is not an easy task, specially for companies or teams missing security specialist. Maybe other ways exist to enabling needed trust. This is what the **Dappy name system** is trying to solve.

[**Dappy name system**](https://github.com/fabcotech/dappy-propositions/blob/master/01_co_resolution.MD) is a hierarchical name system like [DNS]((https://en.wikipedia.org/wiki/Domain_Name_System)), that allows you to have your own [TLD](https://en.wikipedia.org/wiki/Top-level_domain). Dappy name system based on [RChain](https://rchain.coop/), a fully distributed and decentralized public database technology, censorship resistent. RChain brings two main benefits to Dappy name system. It resolves the blockchain trilemma. Decentralization, security and scalability are key points for a public name system like Dappy. Secondly, RChain is enough scalable to persist complex data structures like certificates.

First of all, as **remote trusted certificate store**, Dappy name system distributes trusted certificates to end users. Applications built on top of dappy technologies, such as the [dappy browser](https://github.com/fabcotech/dappy), dappy agent (name and certificate client resolver), and librairies like the [dappy lookup](https://github.com/fabcotech/dappy-lookup) will fetch **certificates dynamically**, removing problems with revocated trusted certificates. Data integrity is resolved using [co-resolution](https://github.com/fabcotech/dappy-propositions/blob/master/01_co_resolution.MD#4-co-resolution), a trustless mecanism, used to query Dappy name system.

Trusted certificates are **always related to their domain** name and they are resolved at runtime by walking through the dappy name system from leaf to root, during name resolution. Companies and institutions don't have to trust and transfer their identity to a third party, like a public certificate authority. 

But **Dappy name system** wants to do more for companies or teams that didn't have their own PKI or don't want to use an external one. To enable clients to trust their server certificate, the idea is to save certificates fingerprints in Dappy name system, in TLSA records like [DANE](https://datatracker.ietf.org/doc/html/rfc7671) does. In that way, clients can verify the authenticity and integrity of server certificates without PKI. It give access 

## What's next ?

Interested by our security solutions ? We provide free assistance for companies that wish to try dappy, you can reach out to us by email contact[at]fabco.tech or through the [dappy.tech/hello](https://dappy.tech/hello) form.